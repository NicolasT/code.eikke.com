Only in gaim-1.1.2-orig: config.h
Only in gaim-1.1.2-orig: gaim.spec
diff -ur gaim-1.1.2-orig/plugins/gaim-remote/remote.c gaim-1.1.2/plugins/gaim-remote/remote.c
--- gaim-1.1.2-orig/plugins/gaim-remote/remote.c	2004-12-31 16:34:05.000000000 +0100
+++ gaim-1.1.2/plugins/gaim-remote/remote.c	2005-01-29 22:07:26.844397504 +0100
@@ -61,6 +61,56 @@
 static int gaim_session = 0;
 static GSList *uis = NULL;
 
+static const char *
+gaim_remote_handle_new_convo(const char *buddy)
+{
+        GaimConvWindow *win;
+        GaimConversation *conv;
+        GList *accounts;
+        GaimAccount *account = NULL;
+        GList *curr;
+        gboolean found;
+
+        buddy += 4;
+        /*
+        * If we already have an open conversation with this buddy, then
+        * just move the conv to this window.  Otherwise, create a new
+        * conv and add it to this window.
+        */
+        conv = gaim_find_conversation(buddy);
+        if (conv != NULL) {
+                win = gaim_conversation_get_window(conv);
+                gaim_conv_window_raise(win);
+                return NULL;
+        }
+
+        accounts = gaim_accounts_get_all();
+        curr = g_list_first(accounts);
+        found = FALSE;
+        while(found == FALSE && curr != NULL) {
+                GaimBuddy *b = NULL;
+                
+                account = (GaimAccount *)curr->data;
+                g_printf("Checking account %s\n", account->username);
+                b = gaim_find_buddy(account, buddy);
+                if(b != NULL) {
+                        found = TRUE;
+                } else {
+                        curr = g_list_next(curr);
+                }
+        }
+        
+        if(found == FALSE || account == NULL)
+                return "No account found";
+        
+        conv = gaim_conversation_new(GAIM_CONV_IM, account, buddy);
+        if(conv == NULL)
+                return "Unable to create conversation";
+        win = gaim_conv_window_new();
+        gaim_conv_window_add_conversation(win, conv);
+        gaim_conv_window_show(win);
+}
+
 /* AIM URI's ARE FUN :-D */
 static const char *
 gaim_remote_handle_uri(const char *uri)
@@ -496,6 +546,13 @@
 	const char *resp;
 	char *send;
 	switch (subtype) {
+        case CUI_REMOTE_NEW_CONVO:
+                send = g_malloc(len + 1);
+                memcpy(send, data, len);
+                send[len] = 0;
+                resp = gaim_remote_handle_new_convo(send);
+                g_free(send);
+                break;
 	case CUI_REMOTE_CONNECTIONS:
 		break;
 	case CUI_REMOTE_URI:
diff -ur gaim-1.1.2-orig/plugins/gaim-remote/remote.h gaim-1.1.2/plugins/gaim-remote/remote.h
--- gaim-1.1.2-orig/plugins/gaim-remote/remote.h	2004-07-28 02:29:52.000000000 +0200
+++ gaim-1.1.2/plugins/gaim-remote/remote.h	2005-01-29 22:07:26.845397352 +0100
@@ -22,7 +22,7 @@
 #ifndef _GAIM_REMOTE_H_
 #define _GAIM_REMOTE_H_
 
-#include <gaim-remote/remote-socket.h>
+#include "remote-socket.h"
 
 
 /* this is the basis of the CUI protocol. */
diff -ur gaim-1.1.2-orig/src/gaim-remote.c gaim-1.1.2/src/gaim-remote.c
--- gaim-1.1.2-orig/src/gaim-remote.c	2004-08-15 18:17:29.000000000 +0200
+++ gaim-1.1.2/src/gaim-remote.c	2005-01-29 22:57:15.025124984 +0100
@@ -48,6 +48,7 @@
 	{"to",      required_argument, NULL, 't'},
 	{"protocol",required_argument, NULL, 'p'},
 	{"from",    required_argument, NULL, 'f'},
+        {"conversation", required_argument, NULL, 'c'},
 	{"quiet",   no_argument,       NULL, 'q'},
 	{"help",    no_argument,       NULL, 'h'},
 	{0,0,0,0}
@@ -59,6 +60,7 @@
 	gboolean help, quiet;
 	char *message, *to, *from;
 	int protocol;
+        char *buddy;
 };
 struct remoteopts opts;
 
@@ -110,6 +112,7 @@
 		"       uri                      Handle AIM: URI\n"
 		"       away                     Popup the away dialog with the default message\n"
 		"       back                     Remove the away dialog\n"
+                "       conversation             Open conversation window with buddy\n"
 		"       quit                     Close running copy of Gaim\n\n"
 		"    OPTIONS:\n"
 		"       -h, --help [command]     Show help for command\n"), name);
@@ -128,8 +131,12 @@
 	memset(&opts, 0, sizeof(opts));
 	opts.protocol = -1;
 
-	while ((i=getopt_long(argc, argv, "m:t:p:f:qh", longopts, NULL)) != -1) {
+	while ((i=getopt_long(argc, argv, "c:m:t:p:f:qh", longopts, NULL)) != -1) {
 		switch (i) {
+                case 'c':
+                        opts.buddy = optarg;
+                        opts.command = g_strdup ("conversation");
+                        break;
 		case 'm':
 			opts.message = optarg;
 			break;
@@ -193,6 +200,34 @@
 	return 0;
 }
 
+int
+send_open_conversation() {
+        int fd = 0;
+        GaimRemotePacket *p = NULL;
+        /* I know this one can be abused, but which IM address is bigger than 1000 chars? */
+        char tmp[1000];
+
+        if (opts.buddy == NULL) {
+                return 1;
+        }
+
+        fd = gaim_remote_session_connect(0);
+        if (fd < 0) {
+                message(_("Gaim not running (on session 0)\nIs the \"Remote Control\" plugin loaded?\n"), 2);
+                return 1;
+        }
+
+        p = gaim_remote_packet_new(CUI_TYPE_REMOTE, CUI_REMOTE_NEW_CONVO);
+        sprintf(tmp, "%04zd%s", strlen(opts.buddy), opts.buddy);
+        gaim_remote_packet_append_string(p, tmp);
+
+        gaim_remote_session_send_packet(fd, p);
+        close(fd);
+        gaim_remote_packet_free(p);
+
+        return 0;
+}
+
 static int
 send_command_uri() {
 	int fd = 0;
@@ -247,6 +282,10 @@
 		message(_("\nSet all accounts as not away.\n"), 1);
 	}
 
+        else if (!strcmp(command, "conversation")) {
+                message(_("\nOpen conversation with requested buddy.\n"), 1);
+        }
+
 	else {
 		show_remote_usage(name);
 	}
@@ -261,10 +300,19 @@
 	textdomain(PACKAGE);
 #endif
 
-	if (get_options(argc, argv)) {
-		show_remote_usage(argv[0]);
-		return 0;
-	}
+	get_options(argc, argv);
+
+        if (opts.command == NULL) {
+                show_remote_usage(argv[0]);
+                return 1;
+        }
+
+        if (!strcmp(opts.command, "conversation")) {
+                if (opts.help)
+                        show_longhelp(argv[0], "conversation");
+                else
+                        return send_open_conversation();
+        }
 
 	if (!strcmp(opts.command, "uri")) {
 		if (opts.help)
